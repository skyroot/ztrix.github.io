<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[From Zero To X]]></title>
  <link href="http://blog.ztrix.me/atom.xml" rel="self"/>
  <link href="http://blog.ztrix.me/"/>
  <updated>2014-02-25T02:30:10+08:00</updated>
  <id>http://blog.ztrix.me/</id>
  <author>
    <name><![CDATA[zTrix]]></name>
    <email><![CDATA[i@ztrix.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codegate CTF 2014 Quals - Weirdshark Writeup]]></title>
    <link href="http://blog.ztrix.me/blog/2014/02/25/codegate-2014-weirdshark-writeup/"/>
    <updated>2014-02-25T01:51:55+08:00</updated>
    <id>http://blog.ztrix.me/blog/2014/02/25/codegate-2014-weirdshark-writeup</id>
    <content type="html"><![CDATA[<p>by <code>zTrix@blue-lotus</code></p>

<p>A pcap file is given here for analysis. check type using <code>file</code></p>

<pre><code># file weird_shark.pcap_f5f1e42dd398f18c43af89ba972b3ee7
weird_shark.pcap_f5f1e42dd398f18c43af89ba972b3ee7: pcap-ng capture file - version 1.0
</code></pre>

<p>Open the file using wireshark, but no luck, wireshark reports malformed file format and refuse to open it.</p>

<p>So we need to extract the packets inside manually.</p>

<!-- more -->


<p>Soon I got the file format document <a href="https://www.winpcap.org/ntar/draft/PCAP-DumpFileFormat.html">here</a>, the file format is really simple, it&rsquo;s organized in blocks, and according to my comprehension, each block contains a single network frame packet.</p>

<p>According to <code>general block structure</code> section in the pcap document, we can easily get the block type, length, and content.</p>

<p>And as for the packet, there are several levels of network protocol headers, a brief hex view shows that the network traffic are HTTP requests and responses, so the protocol stack should be IP + TCP + HTTP</p>

<pre><code>| 6 + 6 bytes MAC addr + 2 bytes (ethertype 08 00) | 20 bytes IP header | 20 bytes TCP header | HTTP Header + HTTP Body |
</code></pre>

<p>the hard thing here to do manually pcap parse is to assemble TCP packets into byte stream, which require a good understanding of TCP control sequence. But we can assume that the network condition is good, no packet loss or retranssmission happens, just assemble them one by one and see what happens.</p>

<p>use the following python code to extract all http content</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">struct</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;weird_shark.pcap_f5f1e42dd398f18c43af89ba972b3ee7&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</span><span class='line'><span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># skip the first two blocks, which seems broken, 0x80 and 0x9c are the block sizes respectively</span>
</span><span class='line'><span class="n">index</span> <span class="o">=</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="mh">0x9c</span>
</span><span class='line'>
</span><span class='line'><span class="n">w</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;http-content.bin&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">total</span><span class="p">:</span>
</span><span class='line'>    <span class="n">block_type</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;hex&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">block_size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">4</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="mi">8</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'>    <span class="n">captured_len</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">20</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="mi">24</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'>    <span class="n">packet_len</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">24</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="mi">28</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">index</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">packet_len</span><span class="p">,</span> <span class="n">captured_len</span><span class="p">,</span> <span class="n">block_type</span>
</span><span class='line'>    <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">28</span><span class="o">+</span><span class="mi">54</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="mi">28</span><span class="o">+</span><span class="n">packet_len</span><span class="p">])</span>
</span><span class='line'>    <span class="n">w</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</span><span class='line'>    <span class="n">index</span> <span class="o">+=</span> <span class="n">block_size</span>
</span><span class='line'>
</span><span class='line'><span class="n">w</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>The result seems very promising,  just concat the packet contents one by one really works! which indicates the network condition is really good. There are several http requests inside</p>

<pre><code>GET / HTTP/1.1
GET /favicon.ico HTTP/1.1
GET /mario.png HTTP/1.1
GET /favicon.ico HTTP/1.1
GET /obama.bmp HTTP/1.1
GET /codegate.jpg HTTP/1.1
GET /multiple.pdf HTTP/1.1
GET /grayhash.jpg HTTP/1.1
</code></pre>

<p>And to my surprise, the flag is not in <code>codegate.jpg</code>, but in <code>multiple.pdf</code></p>

<p>FLAG = <code>FORENSICS_WITH_HAXORS</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHDays CTF IV Quals 2014 - Turututu Writeup]]></title>
    <link href="http://blog.ztrix.me/blog/2014/01/29/phdays-quals-2014-turututu/"/>
    <updated>2014-01-29T11:13:35+08:00</updated>
    <id>http://blog.ztrix.me/blog/2014/01/29/phdays-quals-2014-turututu</id>
    <content type="html"><![CDATA[<p>by <code>zTrix@blue-lotus</code></p>

<p>turututu is an ELF 64-bit executable, after some investigation, it&rsquo;s easy to find out that the task.exe is a native binary generated using <code>ocamlopt</code>.</p>

<p>I know little about <a href="http://en.wikipedia.org/wiki/OCaml">ocaml</a>, so at first I searched a lot trying to get some bytecode or decompiler stuff, or some dedicated debugger for <a href="http://en.wikipedia.org/wiki/OCaml">ocaml</a>, but none of these tools could be found.</p>

<p>So it&rsquo;s time to dive into assembly.</p>

<!-- more -->


<p>From the string constant <code>Sorry, waybe next time...</code>(typo here, LOL!) printed by task.exe, we xref to <code>0x402bf0</code>, and at <code>0x402dda</code>, it seems that some check function is called and then print <code>Gratz!</code> or <code>Sorry, waybe next time...</code>(LOL again!) according to its return value.</p>

<p>Deeper diving reaveals that the check function will invoke a list of functions to check the input value, and whenever something went wrong, the return value would be fail.</p>

<ul>
<li>The first one is at <code>0x4024a0</code>, which is a simple function who parse the arg to a ocaml list of chars.</li>
<li>The second one is at <code>0x402520</code>, which is the check length function. From here we know the list size should be 16.</li>
<li>The third one is at <code>0x402790</code>, ah, a magic string <code>The sky above the port was the color of...</code> can be seen here, it seems that some permutation operations are done here, and will always give positive return value, so just leave it here for later analysis.</li>
<li>The fourth one is at <code>0x402870</code>, this is the real check, and will return false if the check fails.</li>
<li>And there are function 5, 6, 7, will check after function 4. Leave them for later analysis.</li>
</ul>


<p>Ok now we know that we should run the program with a string as argument of 16 bytes, and if the string match something, the <code>task.exe</code> will print happy result. And it&rsquo;s very likely that the input argument should be the flag.</p>

<p>There are a lot of ocaml library functions out there without any signature, making it very hard to read assembly. So I compiled a <code>helloworld</code> program using <code>ocamlopt -g hw.ml</code>, and by comparing the hex code, I can identify a lot of important ocaml functions like <code>camlList__map</code>, <code>camlList_c_call</code>, <code>camlList__combine</code>, <code>caml_equal</code>.</p>

<p>But it&rsquo;s still very hard to figure out the actual behavior under the assembly code. Now it&rsquo;s time for the <a href="http://github.com/longld/peda">peda</a> weapon.</p>

<p>I wrote a small piece of code in <a href="http://github.com/longld/peda">peda</a> to print ocaml list values</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">ocamlist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">):</span>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">    dump ocaml list</span>
</span><span class='line'><span class="sd">    Usage:</span>
</span><span class='line'><span class="sd">        ocamlist register</span>
</span><span class='line'><span class="sd">        ocamlist address</span>
</span><span class='line'><span class="sd">    &quot;&quot;&quot;</span>
</span><span class='line'>    <span class="p">(</span><span class="n">address</span><span class="p">,)</span> <span class="o">=</span> <span class="n">normalize_argv</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">address</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">_missing_argument</span><span class="p">()</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;r&quot;</span><span class="p">):</span>
</span><span class='line'>        <span class="n">address</span> <span class="o">=</span> <span class="n">peda</span><span class="o">.</span><span class="n">getreg</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">address</span> <span class="o">=</span> <span class="n">to_int</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
</span><span class='line'>        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peda</span><span class="o">.</span><span class="n">read_int</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
</span><span class='line'>        <span class="n">address</span> <span class="o">=</span> <span class="n">peda</span><span class="o">.</span><span class="n">read_int</span><span class="p">(</span><span class="n">address</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="mh">0x1000</span><span class="p">:</span>
</span><span class='line'>            <span class="k">break</span>
</span><span class='line'>    <span class="n">msg</span><span class="p">(</span><span class="s">&#39;ocamllist: (</span><span class="si">%d</span><span class="s">) </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">result</span><span class="p">)))</span>
</span><span class='line'>    <span class="k">return</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now fire! gdbinit here</p>

<pre><code>file task.exe
b *0x402baa
r 1234567890ABCDEF
</code></pre>

<p><code>continue</code> at gdb to skip the first function. Then <code>ocamlist $rax</code></p>

<pre><code>Breakpoint 1, 0x0000000000402baa in ?? ()
gdb-peda$ ocamlist $rax
ocamllist: (16) [99, 101, 103, 105, 107, 109, 111, 113, 115, 97, 131, 133, 135, 137, 139, 141]
</code></pre>

<p>Oops, why should ocaml put <code>2x+1</code> value in the list. Never mind.</p>

<p><code>continue</code> two times to skip the length check. Then <code>ocamlist $rax</code></p>

<pre><code>Breakpoint 1, 0x0000000000402baa in ?? ()
gdb-peda$ ocamlist $rax
ocamllist: (16) [101, 135, 115, 111, 97, 141, 139, 99, 137, 133, 113, 103, 109, 107, 105, 131]
</code></pre>

<p>Now we have the permutation table. :)</p>

<p><code>ni</code> into <code>0x402870</code>, and <code>ni</code> to <code>0x402888</code>, <code>ocamlist $rax</code></p>

<pre><code>gdb-peda$ ocamlist $rax
ocamllist: (8) [137, 133, 113, 103, 109, 107, 105, 131]
</code></pre>

<p>so <code>0x4025e0</code> cut the list from index 8, return the second part. <code>ni</code> to <code>0x40289d</code></p>

<pre><code>0x000000000040289d in ?? ()
gdb-peda$ ocamlist $rax
ocamllist: (8) [101, 135, 115, 111, 97, 141, 139, 99]
</code></pre>

<p>we got the first half. Then at <code>0x4028a1</code>, we can identify the function called to be <code>camlList__combine</code> by comparing hex code, we can also know the function <code>camlList__map</code> called at <code>0x4028b0</code>, <code>caml_equal</code> loaded at <code>0x4028bf</code>, and the constant list at <code>0x4028b5</code> is</p>

<pre><code>gdb-peda$ ocamlist 0x621c20
ocamllist: (8) [591, 599, 687, 663, 475, 687, 687, 609]
</code></pre>

<p>So, the logic here become evident. if written in python, it should be sth like this</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">combined</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lst</span><span class="p">[:</span><span class="mi">8</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="mi">8</span><span class="p">:])</span>
</span><span class='line'><span class="n">maped</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">combined</span><span class="p">)</span>
</span><span class='line'><span class="k">assert</span> <span class="n">maped</span> <span class="o">==</span> <span class="p">[</span><span class="mi">591</span><span class="p">,</span> <span class="mi">599</span><span class="p">,</span> <span class="mi">687</span><span class="p">,</span> <span class="mi">663</span><span class="p">,</span> <span class="mi">475</span><span class="p">,</span> <span class="mi">687</span><span class="p">,</span> <span class="mi">687</span><span class="p">,</span> <span class="mi">609</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now we need to know the function f, <code>si</code> into <code>camlList__map</code> and we can find out f at <code>0x402360</code></p>

<pre><code>=&gt; 0x402360:    sar    rbx,1
   0x402363:    lea    rax,[rax+rbx*4]
   0x402367:    ret
</code></pre>

<p>so the python code can be completed</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">combined</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lst</span><span class="p">[:</span><span class="mi">8</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="mi">8</span><span class="p">:])</span>
</span><span class='line'><span class="n">maped</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">combined</span><span class="p">)</span>
</span><span class='line'><span class="k">assert</span> <span class="n">maped</span> <span class="o">==</span> <span class="p">[</span><span class="mi">591</span><span class="p">,</span> <span class="mi">599</span><span class="p">,</span> <span class="mi">687</span><span class="p">,</span> <span class="mi">663</span><span class="p">,</span> <span class="mi">475</span><span class="p">,</span> <span class="mi">687</span><span class="p">,</span> <span class="mi">687</span><span class="p">,</span> <span class="mi">609</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>the next 3 check functions are at <code>0x4029e0</code>, <code>0x402a80</code>, <code>0x402b20</code>, all of them looks like the function we just analysed. It&rsquo;s obvious <code>0x402b20</code> is the simplest. Using the same technique stated above. We can find out this check is actually doing this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">assert</span> <span class="n">lst</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">145</span><span class="p">,</span> <span class="mi">195</span><span class="p">,</span> <span class="mi">233</span><span class="p">,</span> <span class="mi">229</span><span class="p">,</span> <span class="mi">221</span><span class="p">,</span> <span class="mi">137</span><span class="p">,</span> <span class="mi">243</span><span class="p">,</span> <span class="mi">229</span><span class="p">,</span> <span class="mi">233</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>WTF? I just cannot believe this. Fine, we do not need to analyze other functions. Now we can get our most wanted flag</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">rev</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">fun7</span> <span class="o">=</span> <span class="p">[</span><span class="mi">145</span><span class="p">,</span> <span class="mi">195</span><span class="p">,</span> <span class="mi">233</span><span class="p">,</span> <span class="mi">229</span><span class="p">,</span> <span class="mi">221</span><span class="p">,</span> <span class="mi">137</span><span class="p">,</span> <span class="mi">243</span><span class="p">,</span> <span class="mi">229</span><span class="p">,</span> <span class="mi">233</span><span class="p">]</span>
</span><span class='line'><span class="n">fun4</span> <span class="o">=</span> <span class="p">[</span><span class="mi">591</span><span class="p">,</span> <span class="mi">599</span><span class="p">,</span> <span class="mi">687</span><span class="p">,</span> <span class="mi">663</span><span class="p">,</span> <span class="mi">475</span><span class="p">,</span> <span class="mi">687</span><span class="p">,</span> <span class="mi">687</span><span class="p">,</span> <span class="mi">609</span><span class="p">]</span>
</span><span class='line'><span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
</span><span class='line'>    <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fun4</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">fun7</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="n">lst</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">fun7</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span><span class='line'><span class="n">lst</span> <span class="o">=</span> <span class="p">[(</span><span class="n">lst</span><span class="p">[</span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">))]</span>
</span><span class='line'><span class="k">print</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">chr</span><span class="p">,</span> <span class="n">lst</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The flag is <code>HenryDorsettCase</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Defcon 20 小记]]></title>
    <link href="http://blog.ztrix.me/blog/2012/06/08/defcon-ctf-quals-20/"/>
    <updated>2012-06-08T23:35:35+08:00</updated>
    <id>http://blog.ztrix.me/blog/2012/06/08/defcon-ctf-quals-20</id>
    <content type="html"><![CDATA[<p>6 月 2 号到 4 号有幸加入 blue-lotus 参加了 defcon CTF 2012 的比赛，感慨颇深。清华第一次组队参加这个比赛，虽然没进决赛，但第一次参赛能进前 20，也算不错的成绩了。</p>

<!-- more -->


<p>第一次参加 CTF，对于题目最大的感觉就是没有头绪。其实题目涉及面太广，许多题目了解背景知识很快即可破题，不知道的人，想破脑袋也解不出。比如 Forensics 100 的题目，给了个文件系统，大家全在文件系统里面翻，看到一堆又一堆的头文件，但是就是没有结果。等到赛后看了 writeup，发现使用 <a href="http://www.sleuthkit.org/">STK</a> 用一行命令就能得到 key:</p>

<pre><code>blkls -s f100_xxx
</code></pre>

<p>大家大呼坑爹，这谁知道啊！！为什么这样得到的是 key 啊！！有没有什么解释啊！！</p>

<p>但是事实是无情的，虽然是 100 分的题目，只要一个命令，但是我们就是解不出来，而各国牛队则瞬秒。这也许就是经验的差距吧。</p>

<h2>Grab Bag</h2>

<p>Grab Bag 的题目普遍简单，5 道题目我们解出来 4 题，最后的 500 分题到现在 writeup 都没出来，估计也没几个队做出来了。</p>

<h3>grab bag 100</h3>

<p>gb100 的题目就一句话： <code>hack the planet_</code>。我就一直在思考为啥 planet 后面是个下划线。结果没过几分钟，我们组就有人做出来了，key 就是一个 <code>!</code>，当时也没多想，现在才发现，下划线的意思是在最后填一个 <code>char</code>，<code>hack the planet!</code> 可能是一句 hack 文化里面的 slang 吧。所以没有点背景知识就来打酱油真不行。</p>

<h3>grab bag 200</h3>

<p>gb200 的题目是给一个图片和一个 mac double format 文件，mac double format 里面藏了一个链接链到图片的原文件，对比一下发现给的图片后面附加了一个 DNS PTR 查询包。于是大家都想到了构造这个包再发一遍，但是，结果别人得到了结果，我没得到。悲剧！等到赛后看 writeup，发现原来我没有把 source port 指定相同。唉！就差了一步呀。</p>

<h3>grab bag 300</h3>

<p>gb300 是个破解 ATM 取款机的题目，组里有人一眼就看出了规律，太强了！但是人眼看速度不够，只好写程序，好吧，我写得没别人快，就没继续做了。</p>

<h3>grab bag 400</h3>

<p>gb400 是个 SQL 注入，组里有强人立刻就发现了漏洞入口了，好强。没有注入经验，果断不会，好在有强人在，很快解决了。</p>

<h2>Random</h2>

<h3>random 100</h3>

<p>random100 也是让人摸不着头脑的题目，题目是一句话：</p>

<pre><code>How many developers;) did it take to secure Windows 8?
</code></pre>

<p>key 是 152，看了 writeup 也不知道为啥，甚至当时大家做出来的时候，都不知道谁做出来了。我当时写了个脚本把 1 到 1000 都遍历提交了一遍，莫非是我解决的？好开心！</p>

<h3>random 200</h3>

<p>random200 果断不会，今天看 <a href="http://devtrixlabs.com/blog/2012/06/defcon-2012-urandom-200-writeup/">writeup</a>，发现前面都正常，到了最后，作者发现了这个的时候：</p>

<pre><code>fr an
it ha
hi ez
jp er
en-us !!
</code></pre>

<p>他居然直接就猜出了 key 是 <code>icanhazcheezburger!!</code> 。这也太假了吧！！莫非是有我们不知道的 hacker 典故？还是这个人是脑力王？？</p>

<h3>random 300</h3>

<p>random 300 是最 straight forward 的一到题目了，要求用足够少的交换次数把 100000 个 uint16 排序。我开始怕超时写了个 qsort，结果发现交换次数太多。然后准备写 O(n<sup>2</sup>) 的 selection sort，达到最多交换次数 N-1。结果写到一半又被别人抢先了。悲剧！</p>

<h2>Forensics</h2>

<p>binary 和 pwnable 的题都要求 binary 调试，还是各种 MIPS Binary，FreeBSD，我果断看都没看。不过取证这块还是可以看看的。</p>

<h3>Forensics 200</h3>

<p>大家都盯着那几个图片看了。结果又是一道工具题，不知道的人果断是解不出来的，结果也就几行命令：</p>

<pre><code>stegdetect -s 2 2467trash.jpg
outguess -r -e -k “ddtek” 2467trash.jpg key
</code></pre>

<p>原来是道 Steganography 的题目。好吧，现在懂了，不过这个 outguess 里面用到的 ddtek 是怎么来的，writeup 作者说是用了一个字典搜的，换作我们，即使知道用 outguess 也猜不出 key 吧，谁的字典里会有 ddtek ?</p>

<h3>Forensics 300</h3>

<p>Hooray! 这是我唯一解出来并提交的题目！大概就是给了个 OpenWRT 的 firmware 镜像，用 <a href="http://code.google.com/p/firmware-mod-kit/">firmware-mod-kit</a> 解一下，就能得到答案了。太开心了！</p>

<h2>Binary</h2>

<p>突然想起来，其实还是看了一道 binary 题目的，就是 bin 100 的题目。这也是一道好可惜的题目。题目给了一个用 skynet 漏洞的 ssh 和它的输出文件 mac.h，我们也发现了 mac.h 是用直接去反编码的 ASCII。但是谁知道 key 就在里面！！我们都跑去分析给的另外两个 ssh 和 sshd 了。好在最后还是做出来了。不知道是谁试的。其实我印象中记得我把 mac.h 里面的字符串都试了一遍，为啥我们试出来？RPWT？</p>

<h2>总结</h2>

<p>Anyway，比赛已经过去。很高兴能认识很多安全领域的牛人，也很开心打酱油也能做出题来。发个结果图和名字纪念一下吧！期待明年再战！</p>

<p><a href="http://repo.shell-storm.org/CTF/Defcon-20-quals/Scoreboard.txt">最终排名</a> 和最终解题结果：</p>

<p><img class="middle" src="http://blog.ztrix.me/images/defcon-20-blue-lotus.jpg" title="'defcon 20 quals rank'" ></p>

<p>其中绿色是我们解出来的题目，蓝色是我们没解出来，但是有队伍解出来的题目，灰色是还没开放的题目。紫色是当前在做的题目。再发个链接：<a href="http://devpsc.blogspot.jp/2012/06/defcon-20-quals-writeup-collection.html">writeup collection</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MooseFS metadata.mfs 数据恢复纪实]]></title>
    <link href="http://blog.ztrix.me/blog/2012/05/13/restore-mfs-metadata/"/>
    <updated>2012-05-13T16:57:08+08:00</updated>
    <id>http://blog.ztrix.me/blog/2012/05/13/restore-mfs-metadata</id>
    <content type="html"><![CDATA[<p>从这周四下午到周六早上这 40 个小时真是紧张惊险又刺激。以至于我要写篇 blog 来记录一下。</p>

<h2>数据丢失! 天灾人祸!</h2>

<p>实验室跑了一套自己的网盘系统，其中后台数据存储用的是 Moosefs 网络分布式文件系统。这个系统用起来一直很好，直到 2 天前&hellip;</p>

<!-- more -->


<p>周四下午，机房突然断电，听说是隔壁机房安装照明灯的时候不小心短路造成的跳闸（这机房真是！！随便就断电！！还没有UPS！！）。好吧，断电这种事情，也经历多次了，所以大家都不在意。</p>

<p>来电之后，服务器都自动启动了。但是过了很久，服务都没自动启动——服务都是有自动启动脚本的，平常断电之后服务都会自动启动——于是我就手动 ssh 到服务器去查，发现 moosefs 的 master 没有运行。我想可能是自动启动失败了，就尝试手动启动它。结果发现仍然不能启动，给我的提示信息是，metadata.mfs 文件不存在。</p>

<pre><code>can't open metadata file
if this is new instalation then rename metadata.mfs.empty as metadata.mfs
init: file system manager failed !!!
error occured during initialization - exiting
</code></pre>

<p>这个时候我才想起来，moosefs 运行的时候，会把 metadata.mfs 重命名成 metadata.mfs.back，正常结束的时候再重命名回去，而这次是突然断电，所以 metadata.mfs 不存在，mfsmaster 拒绝启动。</p>

<p>于是我再把 metadata.mfs.back 重命名成 metadata.mfs，再次启动，结果又出了错误信息：</p>

<pre><code>loading metadata ...
can't read metadata header
init: file system manager failed !!!
error occured during initialization - exiting
</code></pre>

<p>突然我心里一紧，感觉到问题有点严重。难道断电导致了文件损坏？于是我去检查这个文件，仔细一看，文件大小居然是 0 ！也就是说之前的 200M metadata 信息全部丢失！直接导致 moosefs 里面存的 50T 数据全部变成了废数据。并且，这个文件之前因为一直没人注意，还是没有备份的！！这真是天灾人祸并发呀！</p>

<h2>丢失原因？</h2>

<p>难道有人不小心动了这个文件，或者有人有误操作？我把操作历史看了几遍，确认没有人动这个文件，也没有误操作。那文件是怎么就变成 0 了的呢？</p>

<p>实验室展开了火热的讨论。最终总结出这么几个可能导致文件丢失的原因：</p>

<ul>
<li>ext4 文件系统的 delay allocation 导致的。moosefs 在持久化 metadata 信息的时候，会重写整个文件。他会首先把之前的 metadata.mfs.back 文件重命名成 metadaba.mfs.back.tmp，然后开始写 metadata.mfs.back 文件，写完了 fclose 之后，删除 metadata.mfs.back.tmp。如果断电的时候，正常在进行这么一个过程，那么有可能 fclose 之后，metadata.mfs.back.tmp 也删除了，但是 ext4 的 delay allocation 特性导致文件还没有真正写入到磁盘。（也有可能文件写入了磁盘 block，但是文件 inode 还没有更新）。我们在网上发现有不少人也遇到过同样的断电之后文件大小变成 0 的问题，如这个：<a href="http://www.symantec.com/connect/blogs/ext4-data-recovery-how-recovery-lost-files-ext4-file-system-linux">http://www.symantec.com/connect/blogs/ext4-data-recovery-how-recovery-lost-files-ext4-file-system-linux</a></li>
<li>有可能是 moosefs 写 metadata 失败导致的。阅读了相关源代码之后，我们发现 moosefs 写文件和 fclose 的时候居然从来不判断返回值！有些地方有判断返回值，但是也仅仅打印一句 log，既不做相应错误处理，也不停止。于是就有可能是写文件失败，fclose 也失败，但是它不查返回值，所以又把之前的 metadata.mfs.back.tmp 删除了。</li>
<li>有可能是 ext4 修复导致的。断电造成文件系统出现不一致，然后自动修复之后造成了数据丢失。这突然让我想起了我去年 11 月的遭遇(<a href="https://twitter.com/#!/zhuwl08/status/129538485156716544">https://twitter.com/#!/zhuwl08/status/129538485156716544</a>)，当时写代码写着写着居然代码文件变成了目录，代码也丢了。我用的也是 ext4，这不断电都可以出这样的事情，断电丢个文件也就不算什么了。可见 ext4 还是不够靠谱阿。</li>
</ul>


<h2>数据恢复</h2>

<p>再怎么分析丢失原因也于事无补了，于是大家开始各种尝试恢复数据。我们先把服务器关机，用一个启动盘启动，然后把整个分区 dd 出来，每人发一份尝试恢复。</p>

<h3>数据恢复软件</h3>

<p>首先尝试的是 extundelete 和 ext3grep，尝试了几次之后，发现实在是太弱了，不仅啥都恢复不出来，给个 <code>--restore-all</code> 参数居然直接就崩溃了。</p>

<p>随后发现 R-Linux 这个软件貌似比较强大，于是立刻去下载了一个。试了一下，果然很强大！能进行各种恢复：按时间，按文件类型，按目录。于是开始用它来跑。</p>

<p>我们先试了目录恢复，恢复出了两个文件，但是大小也是 0。再尝试按时间恢复，把最近 5 个月的全部恢复出来。这一下恢复出了一堆数据。居然之前已经删除的各种 log 什么的都还能恢复出来！但是一番搜索之后，我们发现，几个月前的数据都能恢复，单独这个当天的数据怎么也恢复不出来。折腾了很久之后，R-Linux 能耍的花样我们都试了一遍，结果是一无所获。大家都有点灰心丧气，觉得用软件恢复可能性不大了。</p>

<p>另外一个尝试的软件是 photorec，据说也比较强大，但是我没有用过。一位师兄尝试了之后说 photorec 结果还不错，能找到一些开头信息，但是，也找不全，或者文件大小太大，居然有 2G+。那个文件显然没有这么大。</p>

<h3>数据恢复公司</h3>

<p>希望在恢复软件上破灭之后，又在专业数据恢复公司上升起。我们打听到飞客数据恢复中心很不错，有个师兄就拿着数据去了中关村。经过焦急的等待，最终，等来的还是坏消息：inode 被覆盖了，无法恢复数据。</p>

<h3>自己动手</h3>

<p>看来得自己动手了。有人研究 ext4，有人研究是否有可能重建索引，我则去研究 medatata.mfs 文件格式。</p>

<p>moosefs 最坑爹的一点就是：没文档，代码没注释，所以想了解 metadata.mfs 文件格式的话，只能阅读源代码了。</p>

<h4>header</h4>

<p>首先发现的一点就是，metadata.mfs 前 8 个字节是 magic number: &ldquo;MFSM 1.5&#8221;。于是我写了个 c 程序，从头到尾搜索了一遍，总共发现了 17 个。能找到文件开头就标志还有希望！</p>

<p>由于文件开头总是应该在 block 的起始(查了一下 我们用的 ext4 blocksize 是 4096)，所以排除了其中 7 个位置不能被 4096 整除的，还剩下 10 个。</p>

<p>继续看代码，发现 9 &ndash; 12 字节是 maxID，越大表示文件越新。把 10 个开头都看了一遍，发现其中第 9 个最新，文件相对于分区 image 的 offset 为：50440699904 byte。</p>

<p>于是我准备从这里开始，顺藤摸瓜找下去，看看能找到多少有用的信息。如果这个文件格式特征明显的话，应该是能够顺藤摸瓜搜索拼接出来的。</p>

<h4>写程序解析 medadata.mfs</h4>

<p>花了几个小时时间，我利用 moosefs 的源码，写了一个程序去解析 metadata.mfs 文件。一旦解析出错，程序就会自动报错退出，从而知道拼接出来的文件是错误的。这样我就可以去看文件在这个地方大概是什么样的，下面应该是什么样，找出特征写程序搜索。</p>

<p>写完程序之后，把刚才的第 9 个开头开始的前面几M dd 出来。然后跑了一遍程序。运气不错！连续 16M 的数据都是属于 metadata.mfs 的，到了 16M 和 17M 的交界处，程序解析出错了，说明文件到这里不连续了，那么下一段文件在哪呢？是否还在磁盘上呢？</p>

<p>进一步分析发现，这前 16M 数据都是 metadata.mfs 的 node 信息。</p>

<p>这里顺便提一下 metadata.mfs 的文件格式。这个文件由好几个部分组成：首先是 header, 24bytes, 然后是 node 信息，最后用一个空 node 标志结束，然后是 edge 信息，同样用一个空 edge 标志结束。这两个部分比较大，node 部分基本占总文件的一半，edge 部分占四分之一。</p>

<p>node 和 edge 之后，是比较小的一些杂乱信息。最后一部分是比较长的 chunk 信息，最后用一个空 chunk 来标志结束。也就是说这个文件基本上每个区的结束都是用这个区的一个空数据结构来标志的，而不是有一个区 header 指定长度。</p>

<p>找到前面 16M 之后，我就开始琢磨怎么寻找下一段数据。用 xxd 看了一下前面 16M 数据，发现每个 node 信息数据结构里面都有 4 个时间，分别是 atime, ctime, mtime 和 trash time(单位是 s，from epoch)。系统是今年才开始运行的，所以时间都是 2012 年之后，表示成 16 进制的话，就是 4f xx xx xx。于是特征就有了！如果一个 block 能接的上这个文件的前 16M 的话，他里面肯定会有很多时间信息，那就会有很多 4f。</p>

<p>我很快写了一个 c 程序，以 4096(block size) 为单位去读整个分区文件，然后统计这个 block 里面的 4f 的数量，如果超过一个 threshold 的话，说明很可能属于这个文件，那就可以继续分析接的上的问题了。程序跑了十几分钟，结果很不理想，因为太多了。大概有 4000 多个区块组都包含很多 4f，也就是说这 4000 个都有可能是这个文件的，也都有可能是正好接上这个文件的。刚刚才兴奋起来，这下又苦恼了。</p>

<p>不过天无绝人之路。我突然想到，说不定 ext4 分配数据区块给文件的时候，会向后找尽量近的地方。我就看了一下前面 16M 数据在我的分析结果里面的位置，然后发现，在它 32 M 之后，这个有很多 4f 这个特征又明显了起来。我把 32M 之后的数据 dd 了出来。那怎么知道是否和前面 16M 接的上呢？</p>

<p>我又看了一眼代码，发现每个 node 都有一个 id，于是加了一个 printf 去把这个 id 打印出来。结果让我非常惊喜，id 是连续的！所以如果正好能接得上的话，id 应该正好连续！我连忙把前 16M 的数据的最后一个 node id 打了出来，又用 xxd 看了一下后面的数据，id 真的是能正好接上的！于是文件的第二段就这么找到了！！</p>

<p>赶紧把两段数据拼接起来，跑了一遍程序，发现第二段还比较长，两段数据加起来有 56M 之多。到目前为止，文件的前 56M 已经被我恢复出来了。</p>

<p>用同样的方法继续寻找，我很快得到了文件的第 3 4 5 6 段。这样就有了 128M 的数据了。到了 128M 的时候，node 区结束了，到了 edge 区了。</p>

<p>上面的方法不能继续用了，新的挑战来了。虽然方法不能继续用，但是思想肯定还是一致的——果然，edge 区有两个 id 可以用，一个 parent id，一个 child id。用程序打印了一下 id 发现，虽然不是严格连续，但是规律性很明显，基本上是 parent id 很久不变，child id 递减，减到 0 之后，parent id 就变一个。</p>

<p>有了这个特征之后，edge 区也很容易分析了。用这个特征，我恢复出了文件前 168M 的数据。令人兴奋的一点是，这 168M 里面，edge 区在最后 8M 结束了，同时 edge 区之后的几个比较小的区直接也包含在这 8M 里了，最后一个大去 chunk 区在这 8M 里面开始。于是就不需要分析中间几个小区了，只需要分析 chunk 区就行了。胜利就在眼前了！</p>

<p>chunk 区这次也有 id，叫 chunk id，但是，它不连续了。只能分析其他特征了。经过观察发现，chunk 区每个 chunk 大小是固定的，都是 16 字节，前 8 字节是 chunk id，没有明显规律，中间 4 字节是 version，后面 4 字节是 lockedto，而大多数 chunk 的 version 和 lockedto 都很小，基本都是小于 10 的值。哈哈，特征又来了！</p>

<p>我又写了一个 c 程序，每 16 字节为一组进行分析，如果这 16 字节的后面 8 个字节表示成两个 int 值都很小，就符合特征。如果连续很长的数据都符合特征，那么就很可能是 metadata.mfs 的 chunk 区。另外，虽然 chunk id 不严格连续，但是也能找到规律，那就是一段范围内 chunk id 的高位总是相同的，所以我只需要手动分析高位就能尝试连接了。</p>

<p>经过很久的分析和处理，进展越来越多，最后，当我恢复到 200M 左右的时候，程序出错了。到出错的现场查看发现，在一个 block 中间，某个 chunk 之后，数据全是 0 了。而 chunk 区的结束标志就是 0！</p>

<p>这，到底是完成了？！还是出错了？数据被覆盖了？我努力让自己冷静，如果是数据被覆盖的话，那应该整个 block 都被用了，而这是在 block 中间，所以被覆盖的可能性应该不大。当然，如果写一个文件，fseek 到某个位置之后才开始写的话，还是会造成这种中间开始覆盖的。但是我觉得这种可能性不大。另外，根据 chunk id 来看，和现有 chunk 应该数量差不多。所以，我觉得应该是恢复完成的可能性很大！</p>

<p>于是我把文件结束在了 216227836 byte 的地方，在把文件重新跑了一次，果然解析成功了！</p>

<p>再把仍然保存的 moosefs 最新 changelog 拿出来，用 mfsmetarestore 去生成最新的 metadata.mfs 文件，也执行成功了！这说明我恢复出来的文件就是正确的！否则的话，mfsmetarestore 在 restore 的过程中应该会遇到 chunk id 找不到的情况。</p>

<p>真的成功了！！启动 moosefs，一切都显示正常，mfsmount 了之后，文件都能正常访问！! 在分析了将近 20 个小时之后，终于成功了！！</p>

<p>最终恢复出的文件有 200 多 M，由 13 个片段组成：</p>

<pre>
| offset (4k size) | size |
| ---------------- | ---- |
|     12314624     | 16M  |
|     12322816     | 40M  |
|     12341248     | 8M   |
|     12345344     | 16M  |
|     12365824     | 32M  |
|     12388352     | 16M  |
|     12398592     | 8M   |
|     12404736     | 24M  |
|     12421120     | 8M   |
|     12425216     | 8M   |
|     12431360     | 16M  |
|     12460032     | 8M   |
|     12478464     | 6M+  |
</pre>


<p>可见文件数据块分配的时候，offset 是逐渐递增的，并且每个块都在 8M 以上。这些特性也给数据恢复带来了帮助。否则要是文件片段有上百个，每个大小几十 K 的话，那至少要恢复几天才有可能。</p>

<h2>后记和总结</h2>

<p>回想整个恢复的过程，由于 inode 信息都丢失了，所以能做的也就是全盘搜索数据块找特征，然后尝试拼接。所幸 metadata.mfs 文件特征明显，当然最重要的还是各种 id 都比较连续，使得找出数据块之后拼接成为可能。另外一个很重要的原因就是运气，200 多 M 的数据在磁盘上一个字节都没有丢失。不然中间只要丢一个 block，整个恢复都会失败。</p>

<p>所以现在看来，听起来好高深的数据恢复，其实就是 写程序找特征 + 尝试拼接 + 撞大运。</p>

<h3>关于 moosefs</h3>

<p>在长达 20 个小时的数据恢复过程中，我做的最多的一件事情就是骂 moosefs 的作者。因为真的不能忍受他写的代码了。没有文档就算了，居然上千行的程序一点注释都没有！</p>

<p>然后程序里面有各种 if define 条件编译，在 vim 里面还没法匹配 ifdef 和 endif，让我看代码的时候根本不知道哪块代码是运行的代码。这给写解析程序也带来了巨大的麻烦。真不知道作者是怎么理清这么复杂的逻辑的。</p>

<p>另外一个不得不说的地方就是，前面提过的，写文件和关闭文件居然不判断返回值，少有的判断返回值的地方还没有错误处理，直接打印一句 log 草草了事，后面仍然删文件。</p>

<p>当然，数据丢失也是我们自己的过错，对 moosefs 没有足够的了解和重视，以至于忘了备份如此重要的文件。</p>

<p>不管怎样，经历了这一次波折之后，还是学到了很多东西的，也有了一点点数据恢复的经验。生活就是如此跌宕起伏才有意义，C&#8217;est La Vie!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trip to the Silicon Valley]]></title>
    <link href="http://blog.ztrix.me/blog/2012/04/03/trip-to-the-valley/"/>
    <updated>2012-04-03T14:36:09+08:00</updated>
    <id>http://blog.ztrix.me/blog/2012/04/03/trip-to-the-valley</id>
    <content type="html"><![CDATA[<p>还是写点记录文字吧。</p>

<p>3 月 4 号坐上了 Boeing 747，飞机真的很大。人不多，我那一排 3 个座位就我一个人，于是睡得很舒服。</p>

<p>到的时候已经是下午了。能看到加州下午的阳光，斜斜地洒下来，浓淡相宜，周围嘈杂而安静。</p>

<p>飞机上一路基本睡过来的，加上本来作息时间就不规律，倒时差还是很快的。</p>

<!-- more -->


<h2>交通</h2>

<p>到美国第一印象就是公路真是好破啊。坑坑洼洼的，要不是汽车都有减震器，估计坐车会把屁股颠坏。不过公路虽然烂，公路的覆盖是没话说的，到处都是公路，并且没有看到收费站。美国的理念体现在一点一滴。</p>

<p>到了美国，才知道美国人真的是非常遵守交通规则的，很少见到有闯红灯的，并且路中心都是不能走人的，所以想过马路的话，就得先走到马路尽头，然后等绿灯过马路，最后再绕回去。在美国的两个星期里，加上自己，总共也就遇到 5 次不到有人闯红灯。至于我，纯粹是出于好玩，或者让美国之行更加完整，故意闯了一次红灯。</p>

<p>另外一件得到印证的事情就是，美国的车真得都是对行人很友好的。我遇到了好几次，当行人和车在没有红绿灯的小路口相遇的时候，一定是车让行人先走。不得不感慨。</p>

<p>加州有一个可以称为城际铁路的 Caltrain。Caltrain 列车是两层的列车，银灰色条纹车皮，和电影 Source Code 里面的列车景象是多么相似。但是感觉速度好慢，晃晃悠悠的，和国内的列车呼啸完全是两种感觉。后来知道，就在那天，有个人被 Caltrain 撞死了，是 Paypal 的一个高级 VP，默哀。</p>

<p>在 SF 玩的时候，看到了特别陡的公路，一眼看过去，盗梦空间的马路翻转效果就在眼前。另外一个比较好玩的就是有一条公路九曲十八弯的，曲率特别大，在上面开车方向盘不知道要转多少次。</p>

<h2>天气</h2>

<p>加州的天真的很不错。不过昼夜温差大了点，晚上刮起风来，还是很冷的。去的两周里，还下了好几天的雨，不过都不是很大，下得很随意。只要不下雨，没有乌云，天都是很蓝的，很祥和的蓝。不过有乌云的时候，天也很可怕的，一大片乌云黑压压的。</p>

<h2>人</h2>

<p>美国人果然是没有国内的人对减肥有那么大的兴趣的，路上经常能看到很胖很胖的人，男女都有，许多还胖得离谱。另外街上经常能看到各种怪人，诸如看起来在吸毒的，还有比较像疯子的那种一遍走路一边疯疯癫癫唱歌乱叫的。</p>

<p>所以走在美国大街上的感觉是断然不如国内的。胖子多，怪人多，美女少。从我的眼光来看，在美国的两周内，看到的能够称得上漂亮的女人只有 2 个。估计是东西方审美标准差别太大。所以还是走在国内大街上好啊。</p>

<p>我遇到的大多数美国人都还是挺友好的。遇到的唯一不够友好的，是去 Steve Jobs 故居的时候，在路边有个胖女人对我们大声喊叫 You gotta go, 要赶我们走，并称要叫警察，我们解释了半天也没有用。</p>

<p>去渔人码头玩的时候，看到很多街边艺人。最先遇到的是在街边唱歌赚钱的一个三人小乐队。乐器很简朴，但是三个人看起来都好开心，完全不像北京见到的流浪歌手一脸深沉愁眉不展的样子。</p>

<p><img src="http://blog.ztrix.me/images/trip-to-the-valley/happy-singer.jpg" alt="happy-singer" /></p>

<p>另外看到了好几个模仿机器人逗游客玩的那种街边艺术，并且是有声音效果的！可以看到有声效的时候，他的嗓子是有变化的，所以应该是用嗓子发出来的声音吧。真的不容易！</p>

<p>虽然这里是讲人，但顺便提一下动物吧。渔人码头那里有很多鸟，估计是被游客惯坏了，鸟都是不怕人的。这些鸟基本都是三栖的，水陆空都能随意畅游，真羡慕啊。</p>

<p><img src="http://blog.ztrix.me/images/trip-to-the-valley/bird.jpg" alt="bird" /></p>

<h2>Stanford</h2>

<p>去美国只逛了一所大学，就是 Stanford.</p>

<p><img src="http://blog.ztrix.me/images/trip-to-the-valley/stanford.jpg" alt="stanford" /></p>

<p>Stanford 校园真的是很漂亮，整齐幽雅又有情调的那种漂亮，让人非常感觉非常舒适。</p>

<p><img src="http://blog.ztrix.me/images/trip-to-the-valley/stanford2.jpg" alt="stanford" /></p>

<p>在教堂前面拍的，路上一点垃圾都没有！</p>

<h2>Golden Gate Bridge</h2>

<p><img src="http://blog.ztrix.me/images/trip-to-the-valley/golden-gate-bridge.jpg" alt="golden-gate-bridge" /></p>

<p>在加州见到的桥都是斜拉桥，金门大桥也不例外。据说桥的高度允许下面通行航空母舰。真的很壮观的说。</p>

<h2>吃</h2>

<p>看到各种餐厅都有，当然要去尝试一下。两周内，去了日本餐馆，泰国餐馆，越南餐馆，中国餐馆，当然西餐厅也没少去。现在回味起来，感觉日式餐馆和泰国餐馆都不错，越南餐馆吃的那一顿感觉不太好，可能是餐馆太小了。吃的中餐感觉都还不错，虽然到了美国，但是中国的味还都在。还在一家餐馆吃了墨西哥肉卷，味道也还不错，就是不喜欢里面的黑豆。</p>

<p>西餐的话，Pizza，汉堡，生菜Salad 这些，我还是吃的惯的，所以，不挑食就是好呀，到哪都不会饿死。吃的比较爽的一顿是最后临走前吃了一顿牛排，味道真的不错，就是西式刀叉我用起来好别扭，切肉完全切不动。</p>

<p>去渔人码头的时候，吃了一顿海产品，也是吃的很爽的一顿。非常大的龙虾，非常大的螃蟹，吃起来很舒服，一向不喜欢吃海产品的我都可以吃得很有回忆。</p>

<h2>回国</h2>

<p>回来的时候，带了 2 个 ipad 3 和 2 个 iphone4s。入关的时候还惴惴不安的，怕查到交税，结果一直到出门都没看到有人检查的迹象。</p>

<h2>misc</h2>

<p>虽然只去了两周，但是感觉还是很充实的。体会到了很多异国情调。也让我有了更多的思考。</p>

<p>最后来一张飞机上的照片吧，可以看到地球是圆的。</p>

<p><img src="http://blog.ztrix.me/images/trip-to-the-valley/plane.jpg" alt="plane" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一签水过]]></title>
    <link href="http://blog.ztrix.me/blog/2012/02/02/visa-1k-water-pass/"/>
    <updated>2012-02-02T09:52:27+08:00</updated>
    <id>http://blog.ztrix.me/blog/2012/02/02/visa-1k-water-pass</id>
    <content type="html"><![CDATA[<p>一签水过，来这里稍微记录一下，以备后用。</p>

<h2>预约</h2>

<p>预约是很纠结的一件事情。尤其是我预约的时候是 1 月 19 左右，当时在家，只好请还在北京的同学帮忙去中信银行买了一下加密电话卡，付了签证费用。</p>

<p>第一次打电话还算顺利，准备好各个号码之后，拨通电话，预约日期只有 1 月 27 到 1 月 31 号可以选，2 月好像还没开始。于是预约了 30 号。</p>

<!-- more -->


<p>到了 29 号的时候，邀请信还没寄到（B1 签证），无奈只好再去买电话卡重新预约。结果 29 号是星期天，人工电话服务周日不工作。而我预约的是 30 号早上 9:15 的签证。</p>

<p>30 号早上 7 点钟就爬了起来，准备重新预约。结果电话一直打不进去，不停地说密码有效期是 12 个月，如果用完 8 分钟或者 12 分钟则需要重新付款云云。难道我打电话出了什么错？总之就一直打不通，到现在也没弄明白是为什么。好吧。我就放大使馆鸽子了。睡觉去了。</p>

<p>一睡睡到 12 点。起床后又打了几遍，依然不通。等到了下午 5 点左右又尝试了一遍，居然通了！想起来上次也是 5 点左右打的，难道还和时间有关？是不是上午打电话的人太多了？占线？总之完全没搞懂。</p>

<p>打通了之后一问，只有 2 月 1 号和 2 号可以预约到。就预约了 2 月 2 号早上 8 点的。现在想想其实挺险的。因为最后邀请函到 2 月 1 号下午才到。如果到不了的话，那么就得再次改预约，而 30 天内只能预约 2 次。</p>

<h2>准备材料</h2>

<p>B1 签证要准备的材料还是很多的。看了一下网上的流传清单，各种财产证明，工作证明，结婚证什么的，很多。好在我是学生，一概不需要。最后准备的也就是中英文简历。然后把学生证，成绩单，邀请函。感觉准备的东西太少很不踏实。但也没有办法，这个时间学校都没开门，集体户口没法去拿。身份证复印件也没带。虽然准备的东西少感觉不踏实，不过也很轻快，至少找什么材料都能很快找到。</p>

<h2>签证</h2>

<p>2 月 2 号早上 6 点我就爬了起来。吃了点东西，扔下手机，6 点半就出发了。打的将近半个小时就到了。然后就是排队。看了一下在我前面的大概有 30 多个。还算很早的。</p>

<p>7 点 15 左右进场。4 人编一组进去排队递交材料。交完材料后去摁指纹，然后就在摁指纹旁边的窗口排队等待。</p>

<p>一开始我还以为还有什么其他手续，就在那里等，结果等工作人员安排我们到一个新开的窗口的时候，发现居然已经开始签证面谈了。我又是排 4 人一组第一位的，心里紧了一下，连忙把材料递了进去。</p>

<p>“你好”。VO 用不是很标准的汉语说。</p>

<p>&ldquo;Hello.&rdquo; 我表明一下我是可以用英语面谈的。</p>

<p>然后签证官问我去美国做什么。我就按准备好的来回答了一下。接着他又问了我准备在美国待多长时间，以前去过美国没，以前去过其他国家没。然后他看到我是 THU 的学生，就向我确认了一下，我就递上了我的学生证。</p>

<p>&ldquo;Have a nice trip!&rdquo;. 真没想到这么快。大概才问了 5 个问题就过了。我越来越觉得做为 THU 的学生真是好处多多。总之还是觉得运气还是很不错的。可能早上刚开始，VO 的心情也还不错吧。</p>

<p>随后就去邮局办了手续。结果到了邮局还没开门，才 8 点半左右。看到网上有人排队到下午 1 点多，感慨幸亏起得比较早。作为第一批进馆的，一切都还比较有条不紊。如果到了 9 点多进馆，乱哄哄的，估计真要到下午才能办完了。</p>

<h2>感想</h2>

<ul>
<li>早起的鸟儿有虫吃。到的早，无论自己还是别人都没有丝毫疲劳，心情都很舒畅。做事要趁早。</li>
<li>虽然准备的材料只用到了一点点。但是从准备的角度来说，还是应该都备齐的。因为政府办事本身就是一个随机性很大的事情，程序和手续还很繁杂。万一一个材料没备齐，VO 让你准备好下次再来就很麻烦了。所以还是要尽自己的努力把要准备的都准备好，争取一次通过。</li>
</ul>


<h2>后续</h2>

<p>2013 年 8 月有机会去美国参加比赛，但是由于怕 check 就走了旅游签证 B2。签证的时候很纠结到底是面签还是递签，面签随机性太大，递签又怕类型不同会有问题（上次 B1 这次 B2），而且那个时候还是要送到广州递签的，一来一回又消耗不少光阴。最后还是选择了递签，结果大概一周多的样子就查到已经通过了。看来担心是多余的。另外中信银行现在递签已经不要钱了，为啥总是感觉怪怪的。</p>
]]></content>
  </entry>
  
</feed>
